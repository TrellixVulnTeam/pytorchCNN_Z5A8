import pycocotools

import os

import torch
import torch.utils.data
from PIL import Image
import pandas as pd

from torchvision.models.detection.faster_rcnn import FastRCNNPredictor

from engine import train_one_epoch, evaluate
import utils
import transforms as T


def parse_one_annot(path_to_data_file, filename):
    data = pd.read_csv(path_to_data_file)
    boxes_array = data[data["filename"] == filename][["xmin", "ymin", "xmax", "ymax"]].values

    return boxes_array


class RaccoonDataSet(torch.utils.data.Dataset):
    def __init__(self, root, data_file, transform=None):
        self.root = root
        self.transform = transform
        self.imgs = sorted(os.listdir(os.path.join(root, "images")))
        self.path_tp_data_file = data_file

    def __getitem__(self, idx):
        #   load images and bounding boxes
        img_path = os.path.join(self.root, "images", self.imgs[idx])
        img = Image.open(img_path).convert("RGB")
        box_list = parse_one_annot(self.path_tp_data_file, self.imgs[idx])
        boxes = torch.as_tensor(box_list, dtype=torch.float32)

        num_objs = len(box_list)

        # there is only one class
        labels = torch.ones((num_objs,), dtype=torch.int64)
        image_id = torch.tensor([idx])
        area = (boxes[:, 3] - boxes[:, 1]) * (boxes[:, 2] - boxes[:, 0])
        # supposed all instances are not crowd

        iscrowd = torch.zeros((num_objs,), dtype=torch.int64)
        target = {"boxes": boxes, "labels": labels, "image_id": image_id, "area": area, "iscrowd": iscrowd}
        print(labels)
        print(image_id)
        print(area)
        print(iscrowd)
        if self.transform is not None:
            img, target = self.transform(img, target)
            return img, target

    def __len__(self):
        return len(self.imgs)


dataset = RaccoonDataSet(root="/home/thorben/Documents/CustomCNN/raccoon_dataset",
                         data_file="/home/thorben/Documents/CustomCNN/raccoon_dataset/data/raccoon_labels.csv")
dataset.__getitem__(0)
